#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
four_angles/train_step3_routeA.py

Step3 (Route A):
- Train YOLO detect with per-batch 50% static + 50% runtime synthetic data.
- ✅ Runtime synthetic data is generated by the SAME synth engine as Step1:
    four_angles/src/synth/rigid_synth.py::generate_dataset
- ✅ Lightweight sanity-check: save 1 (or N) runtime debug image(s) per epoch
  to dataset_yolo/_runtime_check/ for quick visual inspection.
- ✅ Fix WinError 32: do NOT delete runtime folder that is being read by dataloader workers.
  Instead: write runtime into epoch subfolders: _runtime/rt_e000, rt_e001, ...

Outputs (Ultralytics):
- see console line: "Logging results to ..."
- controlled by model.train(project=..., name=..., exist_ok=...)
"""

from __future__ import annotations

import math
import os
import random
import shutil
import sys
from pathlib import Path
from typing import List, Tuple, Optional

import cv2
import numpy as np
import torch

# ✅ ensure project root on sys.path (fix: No module named 'four_angles')
ROOT = Path(__file__).resolve().parents[1]  # .../Business-card-information-extraction
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from four_angles.src.synth.rigid_synth import (  # noqa: E402
    SynthConfig,
    generate_dataset,
    list_images,
)

# =========================
# CONFIG (edit here)
# =========================
DATASET_ROOT = Path(r"four_angles/assets/step2_out_dataset_yolo")
DATA_YAML = DATASET_ROOT / "dataset.yaml"
STATIC_TRAIN_IMG_DIR = DATASET_ROOT / "images" / "train"
STATIC_VAL_IMG_DIR = DATASET_ROOT / "images" / "val"

# Step1素材（Step3 runtime 使用同一套素材）
BG_DIR = Path(r"data/background")
CARD_DIR = Path(r"data/business_card_raw")

# runtime 根目录（内部按 epoch 建子目录）
RUNTIME_ROOT = DATASET_ROOT / "_runtime"
RUNTIME_KEEP_LAST_N_EPOCHS = 3  # 只保留最近N个epoch的runtime目录；更老的尝试删除（失败则忽略）

# ---- lightweight runtime sanity check ----
RUNTIME_CHECK_DIR = DATASET_ROOT / "_runtime_check"
RUNTIME_CHECK_SAMPLES_PER_EPOCH = 1  # 每个 epoch 保存 1 张（想 3 张就改 3）
RUNTIME_CHECK_DRAW_CORNER_CENTERS = True

# train hyperparams
MODEL_WEIGHTS = "yolo11m.pt"
EPOCHS = 100
IMGSZ = 960
BATCH = 4          # 建议偶数（保证每 batch 50/50）
WORKERS = 4
DEVICE = 0
SEED = 42

# ✅ 合成参数模板：请确保与 Step1 synth_step1_generate.py 的 CONFIG 一致（保证“同款数据分布”）
SYNTH_TEMPLATE = dict(
    out_w=None,
    out_h=None,
    min_cards=2,
    max_cards=4,
    margin_to_img=150,
    min_gap_between_cards=60,
    fixed_card_w=700,
    angle_min=0.0,
    angle_max=360.0,
    corner_box_ratio=0.40,
    corner_box_min=120,
    corner_box_max=220,
    max_place_trials_per_card=140,
    max_image_retries=40,
)

# Ultralytics output dir control
ULTRA_PROJECT = str(Path("four_angles") / "runs")
ULTRA_NAME = "step3_detect"
ULTRA_EXIST_OK = True


# =========================
# Small FS helpers (Windows-safe)
# =========================
def safe_rmtree(p: Path) -> bool:
    """Best-effort delete; return True if deleted, False if failed (e.g., WinError 32)."""
    if not p.exists():
        return True
    try:
        shutil.rmtree(p)
        return True
    except PermissionError:
        return False
    except OSError:
        return False


def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


# =========================
# Mixed loader: 50% static + 50% runtime per batch
# =========================
class MixedProxyDataset:
    """Route (src, idx) to static or runtime dataset."""
    def __init__(self, ds_static, ds_dyn):
        self.ds_static = ds_static
        self.ds_dyn = ds_dyn
        self.collate_fn = getattr(ds_static, "collate_fn", None) or getattr(ds_dyn, "collate_fn", None)

    def __len__(self) -> int:
        return max(len(self.ds_static), 1)

    def __getitem__(self, item):
        src, idx = item
        return self.ds_static[int(idx)] if src == 0 else self.ds_dyn[int(idx)]


class MixedBatchSampler:
    """Each batch: half static, half runtime; num_batches controls epoch length."""
    def __init__(self, n_static: int, n_dyn: int, batch_size: int, num_batches: int, seed: int):
        self.n_static = int(n_static)
        self.n_dyn = int(n_dyn)
        self.batch_size = int(batch_size)
        self.num_batches = int(num_batches)
        self.seed = int(seed)
        self.bs_static = max(1, self.batch_size // 2)
        self.bs_dyn = self.batch_size - self.bs_static

    def __len__(self) -> int:
        return self.num_batches

    def __iter__(self):
        rng = random.Random(self.seed)
        s_idx = list(range(self.n_static))
        d_idx = list(range(self.n_dyn))
        rng.shuffle(s_idx)
        rng.shuffle(d_idx)
        sp, dp = 0, 0

        for _ in range(self.num_batches):
            batch = []
            for _ in range(self.bs_static):
                if sp >= len(s_idx):
                    rng.shuffle(s_idx)
                    sp = 0
                batch.append((0, s_idx[sp]))
                sp += 1
            for _ in range(self.bs_dyn):
                if dp >= len(d_idx):
                    rng.shuffle(d_idx)
                    dp = 0
                batch.append((1, d_idx[dp]))
                dp += 1
            rng.shuffle(batch)
            yield batch


# =========================
# Lightweight runtime sanity check (draw yolo bboxes)
# =========================
def _read_yolo_labels(lbl_path: Path):
    rows = []
    if not lbl_path.exists():
        return rows
    txt = lbl_path.read_text(encoding="utf-8").strip()
    if not txt:
        return rows
    for line in txt.splitlines():
        parts = line.strip().split()
        if len(parts) != 5:
            continue
        cid = int(float(parts[0]))
        cx, cy, w, h = map(float, parts[1:])
        rows.append((cid, cx, cy, w, h))
    return rows


def _yolo_to_xyxy(cid, cx, cy, w, h, W, H):
    x1 = (cx - w / 2) * W
    y1 = (cy - h / 2) * H
    x2 = (cx + w / 2) * W
    y2 = (cy + h / 2) * H
    x1 = max(0, min(W - 1, x1))
    x2 = max(0, min(W - 1, x2))
    y1 = max(0, min(H - 1, y1))
    y2 = max(0, min(H - 1, y2))
    return cid, x1, y1, x2, y2


def save_runtime_check_images(runtime_dir: Path, out_dir: Path, epoch: int, k: int, seed: int):
    """
    Sample k images from runtime_dir/images and draw YOLO boxes from runtime_dir/labels.
    """
    img_dir = runtime_dir / "images"
    lbl_dir = runtime_dir / "labels"
    if not img_dir.exists() or not lbl_dir.exists():
        return

    imgs = sorted([p for p in img_dir.iterdir() if p.is_file() and p.suffix.lower() in {".jpg", ".jpeg", ".png"}])
    if not imgs:
        return

    rng = random.Random(seed)
    picks = rng.sample(imgs, k=min(k, len(imgs)))

    ensure_dir(out_dir)

    for i, img_path in enumerate(picks):
        img = cv2.imdecode(np.fromfile(str(img_path), dtype=np.uint8), cv2.IMREAD_COLOR)
        if img is None:
            continue
        H, W = img.shape[:2]
        lbl_path = lbl_dir / f"{img_path.stem}.txt"
        rows = _read_yolo_labels(lbl_path)

        for (cid, cx, cy, bw, bh) in rows:
            cid, x1, y1, x2, y2 = _yolo_to_xyxy(cid, cx, cy, bw, bh, W, H)
            color = (0, 0, 255) if cid == 0 else (255, 0, 255)  # card red, corners magenta
            cv2.rectangle(img, (int(x1), int(y1)), (int(x2), int(y2)), color, 2)

            if RUNTIME_CHECK_DRAW_CORNER_CENTERS and cid in (1, 2, 3, 4):
                ccx = int((x1 + x2) / 2)
                ccy = int((y1 + y2) / 2)
                cv2.circle(img, (ccx, ccy), 4, (0, 255, 255), -1)

            cv2.putText(img, str(cid), (int(x1), max(0, int(y1) - 4)),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)

        out_path = out_dir / f"epoch_{epoch:03d}_{i:02d}_{img_path.stem}.jpg"
        ok, buf = cv2.imencode(".jpg", img)
        if ok:
            buf.tofile(str(out_path))


# =========================
# Ultralytics callback wiring
# =========================
def register_callback(model, event_name: str, fn):
    if hasattr(model, "add_callback"):
        model.add_callback(event_name, fn)
        return
    cbs = getattr(model, "callbacks", None)
    if isinstance(cbs, dict):
        cbs.setdefault(event_name, []).append(fn)
        return
    raise RuntimeError("Cannot register callback (no add_callback/callbacks).")


def _ddp_barrier_if_available():
    try:
        import torch.distributed as dist
        if dist.is_available() and dist.is_initialized():
            dist.barrier()
    except Exception:
        pass


def _cleanup_old_runtime_dirs(current_epoch: int) -> None:
    """
    Best-effort cleanup: keep only last N epoch folders. If Windows locks prevent deletion, ignore.
    """
    if RUNTIME_KEEP_LAST_N_EPOCHS <= 0:
        return
    threshold = current_epoch - RUNTIME_KEEP_LAST_N_EPOCHS
    if threshold < 0:
        return
    # delete directories <= threshold
    for d in sorted(RUNTIME_ROOT.glob("rt_e*")):
        try:
            name = d.name
            if not name.startswith("rt_e"):
                continue
            ep = int(name.replace("rt_e", ""))
            if ep <= threshold:
                ok = safe_rmtree(d)
                if not ok:
                    # ignore; will try again later
                    pass
        except Exception:
            continue


def build_mixed_train_loader(trainer) -> None:
    """
    ✅ Core:
    - runtime generation calls SAME synth engine as Step1 (generate_dataset from rigid_synth).
    - runtime is written into epoch subfolder to avoid WinError 32.
    - rebuild a 50/50 mixed dataloader and assign trainer.train_loader.
    """
    from ultralytics.data.build import InfiniteDataLoader, build_yolo_dataset, seed_worker

    epoch = int(getattr(trainer, "epoch", 0))
    epoch_seed = SEED + 1000 * epoch

    static_count = len(list_images(STATIC_TRAIN_IMG_DIR))
    if static_count <= 0:
        raise RuntimeError(f"No static train images found: {STATIC_TRAIN_IMG_DIR}")

    batch = int(getattr(trainer.args, "batch", BATCH))
    num_batches = int(math.ceil(static_count / max(batch, 1)))

    bs_static = batch // 2
    bs_dyn = batch - bs_static
    dyn_images = num_batches * bs_dyn

    rank = int(getattr(trainer, "rank", 0))

    # runtime folder for this epoch (safe: never delete other epoch folder that may be in use)
    runtime_epoch_dir = RUNTIME_ROOT / f"rt_e{epoch:03d}"

    # 1) Generate runtime dataset (rank0 only)
    if rank == 0:
        ensure_dir(RUNTIME_ROOT)
        # clear only THIS epoch folder (not in use yet)
        safe_rmtree(runtime_epoch_dir)
        ensure_dir(runtime_epoch_dir)

        cfg = SynthConfig(
            bg_dir=BG_DIR,
            card_dir=CARD_DIR,
            out_dir=runtime_epoch_dir,
            num_images=dyn_images,
            save_debug=False,  # training: don't write debug_vis
            num_workers=4,     # callback: stable; tune later if needed
            seed=epoch_seed,
            **SYNTH_TEMPLATE,
        )
        generate_dataset(cfg, overwrite=False)

        # 2) Lightweight runtime sanity check (save 1 image/epoch)
        if RUNTIME_CHECK_SAMPLES_PER_EPOCH > 0:
            save_runtime_check_images(
                runtime_dir=runtime_epoch_dir,
                out_dir=RUNTIME_CHECK_DIR,
                epoch=epoch,
                k=RUNTIME_CHECK_SAMPLES_PER_EPOCH,
                seed=epoch_seed + 7,
            )

        # 3) Best-effort cleanup older runtime dirs
        _cleanup_old_runtime_dirs(epoch)

    _ddp_barrier_if_available()

    # 4) Build Ultralytics datasets
    stride = 32
    try:
        s = trainer.model.stride
        stride = int(max(s)) if hasattr(s, "__iter__") else int(s)
    except Exception:
        stride = 32

    ds_static = build_yolo_dataset(
        cfg=trainer.args,
        img_path=str(STATIC_TRAIN_IMG_DIR),
        batch=batch,
        data=trainer.data,
        mode="train",
        rect=False,
        stride=stride,
    )
    ds_dyn = build_yolo_dataset(
        cfg=trainer.args,
        img_path=str(runtime_epoch_dir / "images"),
        batch=batch,
        data=trainer.data,
        mode="train",
        rect=False,
        stride=stride,
    )

    mixed_ds = MixedProxyDataset(ds_static, ds_dyn)
    sampler = MixedBatchSampler(
        n_static=len(ds_static),
        n_dyn=len(ds_dyn),
        batch_size=batch,
        num_batches=num_batches,
        seed=epoch_seed,
    )

    nw = min(os.cpu_count() or 8, int(getattr(trainer.args, "workers", WORKERS)))
    g = torch.Generator()
    g.manual_seed(epoch_seed)

    loader = InfiniteDataLoader(
        dataset=mixed_ds,
        batch_sampler=sampler,
        num_workers=nw,
        pin_memory=True,
        worker_init_fn=seed_worker,
        generator=g,
        collate_fn=mixed_ds.collate_fn,
    )

    trainer.train_loader = loader
    trainer.trainset = mixed_ds

    if rank == 0:
        print(
            f"[Step3 RouteA] epoch={epoch} static={len(ds_static)} runtime={len(ds_dyn)} "
            f"batches={num_batches} batch={batch} (static={bs_static}, runtime={bs_dyn})"
        )
        if RUNTIME_CHECK_SAMPLES_PER_EPOCH > 0:
            print(f"[Check] runtime debug saved to: {RUNTIME_CHECK_DIR.resolve()}")
        print(f"[Runtime] using: {runtime_epoch_dir.resolve()}")


def main():
    from ultralytics import YOLO

    # basic checks
    if not DATA_YAML.exists():
        raise FileNotFoundError(f"dataset.yaml not found: {DATA_YAML}")
    if not STATIC_TRAIN_IMG_DIR.exists():
        raise FileNotFoundError(f"static train dir not found: {STATIC_TRAIN_IMG_DIR}")
    if not STATIC_VAL_IMG_DIR.exists():
        raise FileNotFoundError(f"val dir not found: {STATIC_VAL_IMG_DIR}")
    if not BG_DIR.exists():
        raise FileNotFoundError(f"BG_DIR not found: {BG_DIR}")
    if not CARD_DIR.exists():
        raise FileNotFoundError(f"CARD_DIR not found: {CARD_DIR}")

    random.seed(SEED)
    np.random.seed(SEED)
    torch.manual_seed(SEED)

    model = YOLO(MODEL_WEIGHTS)

    # ✅ Register ONLY epoch-start callback (avoid generating runtime twice at epoch 0)
    register_callback(model, "on_train_epoch_start", lambda trainer: build_mixed_train_loader(trainer))

    model.train(
        data=str(DATA_YAML),
        epochs=EPOCHS,
        imgsz=IMGSZ,
        batch=BATCH,
        workers=WORKERS,
        device=DEVICE,
        seed=SEED,
        cache=False,
        rect=False,

        # ✅ control output directory
        project=ULTRA_PROJECT,
        name=ULTRA_NAME,
        exist_ok=ULTRA_EXIST_OK,

        # ---- Disable augmentations ----
        mosaic=0.0,
        mixup=0.0,
        copy_paste=0.0,
        degrees=0.0,
        translate=0.0,
        scale=0.0,
        shear=0.0,
        perspective=0.0,
        fliplr=0.0,
        flipud=0.0,
        hsv_h=0.0,
        hsv_s=0.0,
        hsv_v=0.0,
        erasing=0.0,
        close_mosaic=0,

        amp=True,
        pretrained=True,
    )

    # Ultralytics will print the actual "Logging results to ..." path.
    # Typically weights are under: <that_dir>/weights/best.pt and last.pt
    print("[OK] Training finished.")
    print("Check console line: 'Logging results to ...' for exact output folder.")


if __name__ == "__main__":
    main()
